{
  "name": "rest-hapi",
  "tagline": "A RESTful API generator for hapi.",
  "body": "# rest-hapi\r\nA RESTful API generator built around the [hapi](https://github.com/hapijs/hapi) framework and [mongoose](https://github.com/Automattic/mongoose) ODM.\r\n\r\n[![Build Status](https://travis-ci.org/JKHeadley/rest-hapi.svg?branch=master)](https://travis-ci.org/JKHeadley/rest-hapi)\r\n\r\nrest-hapi is a framework intended to abstract the work involved in setting up API routes/validation/handlers/etc. for the purpose of rapid app development.  At the same time it provides a powerful combination of [relational](#associations) structure with [NoSQL](#creating-endpoints) flexibility.  You define your models and the rest is done for you.  Have your own API server up and running in minutes!\r\n\r\n## Features\r\n\r\n* Automatic generation of CRUD endpoints with middleware support\r\n* Automatic generation of association endpoints\r\n* [joi](https://github.com/hapijs/joi) validation\r\n* User password encryption support\r\n* Optional token authentication for all generated endpoints\r\n* Swagger docs for all generated endpoints via [hapi-swagger](https://github.com/glennjones/hapi-swagger)\r\n* Query parameter support for sorting, filtering, pagination, and embedding of associated models\r\n\r\n## Live demo\r\n\r\nView the swagger docs for the live demo:\r\n\r\nhttp://ec2-35-162-67-113.us-west-2.compute.amazonaws.com:8124/\r\n\r\n## Readme contents\r\n- [Requirements](#requirements)\r\n- [Installation](#installation)\r\n- [Running the app](#running-the-app)\r\n- [Configuration](#configuration)\r\n- [Testing](#testing)\r\n- [Swagger documentation](#swagger-documentation)\r\n- [Creating endpoints](#creating-endpoints)\r\n- [Associations](#associations)\r\n- [Route customization](#route-customization)\r\n- [Querying](#querying)\r\n- [Validation](#validation)\r\n- [Middleware](#middleware)\r\n- [Additional endpoints](#additional-endpoints)\r\n- [Token authentication](#token-authentication)\r\n- [License](#license)\r\n- [Questions](#questions)\r\n- [Future work](#future-work)\r\n- [Contributing](#contributing)\r\n\r\n\r\n## Requirements\r\n\r\nYou need [Node.js](https://nodejs.org/en/) installed and you'll need [MongoDB](https://docs.mongodb.com/manual/installation/) installed and running.  You will also need the [gulp](https://www.npmjs.com/package/gulp) node package installed.\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Installation\r\n\r\n```\r\n$ git clone https://github.com/JKHeadley/rest-hapi.git\r\n$ cd rest-hapi\r\n$ npm install\r\n```\r\n### First time setup/Demo\r\n**WARNING**: This will clear all data in the following MongoDB collections (in the db defined in ``config.local.js``) if they exist: ``users``, ``roles``.\r\n\r\nIf you would like to seed your database with some demo models/data, run:\r\n```\r\n$ gulp seed\r\n```\r\nNOTE: The password for all seed users is ``1234``.\r\n\r\nYou can use these models as templates for your models or delete them later if you wish.\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Running the app\r\n```\r\n$ gulp serve:local\r\n```\r\nor just\r\n```\r\n$ gulp\r\n```\r\nThen point your browser to [http://localhost:8124/](http://localhost:8124/) to view the swagger docs.\r\n\r\n[gulp-nodemon](https://www.npmjs.com/package/gulp-nodemon) watches for changes in server code and restarts the app automatically.\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Configuration\r\n\r\nEdit the config file relevant to your environment (local, development, production).  The default config\r\nfile is ```/api/config.local.js```.  Here you can set the server port, mongodb URI, and authentication.\r\n\r\n[Back to top](#rest-hapi)\r\n\r\n# Testing\r\nTo run tests:\r\n```\r\n$ gulp test\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Swagger documentation\r\n\r\nSwagger documentation is automatically generated for all endpoints and can be viewed by pointing a browser\r\nat the server URL.  By default this will be [http://localhost:8124/](http://localhost:8124/).  The swagger docs provide quick \r\naccess to testing your endpoints along with model schema descriptions and query options.\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Creating endpoints\r\n\r\nRestful endpoints are automatically generated based off of any mongoose models that you add to the \r\n``/api/models`` folder with the file structure of ``{model name}.model.js``.  These models must adhere to the following format:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n    var Schema = new mongoose.Schema({\r\n        /*fill in schema fields*/\r\n    });\r\n\r\n    Schema.statics = {\r\n        collectionName: /*your model name*/,\r\n        routeOptions: {}\r\n    };\r\n\r\n    return Schema;\r\n};\r\n```\r\n\r\nAs a concrete example, here is a ``user`` model:\r\n\r\n``/api/models/user.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName: modelName\r\n    routeOptions: {}\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\nThis will generate the following CRUD endpoints:\r\n\r\n```\r\nGET /user           Get a list of users\r\nPOST /user          Create a new user\r\nGET /user/{_id}     Get a specific user\r\nPUT /user/{_id}     Update a user\r\nDELETE /user/{_id}  Delete a user\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Associations\r\n\r\nThe rest-hapi framework supports model associations that mimic associations in \r\na relational database.  This includes one-one, one-many, many-one, and many-many\r\nrelationships.  Associations are created by adding the relevant schema fields\r\nand populating the ``associations`` object within ``routeOptions``.  Associations\r\nexists as references to a document's ``_id`` field, and can be populated to return \r\nthe associated object.  See [Querying](#querying) for more details on how to populate\r\nassociations.\r\n\r\n### ONE_ONE\r\n\r\nBelow is an example of a one-one relationship between a ``user`` model and a\r\n``dog`` model. Notice the ``dog`` and ``owner`` fields in the schemas.  A schema\r\nfield is required for associations of type ``ONE_ONE`` or ``MANY_ONE``.  This\r\nfield must match the association name, include a type of ``ObjectId``, and\r\ninclude a ``ref`` property with the associated model name.\r\n\r\nEach association must be added to an ``associations`` object within the\r\n``routeOptions`` object. The ``type`` and ``model`` fields are\r\nrequired for all associations.\r\n\r\n``/api/models/user.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    },\r\n    dog: {\r\n      type: Types.ObjectId,\r\n      ref: \"dog\"\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        dog: {\r\n          type: \"ONE_ONE\",\r\n          model: \"dog\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\n``/api/models/dog.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"dog\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    name: {\r\n      type: Types.String,\r\n      required: true\r\n    },\r\n    breed: {\r\n      type: Types.String\r\n    },\r\n    owner: {\r\n      type: Types.ObjectId,\r\n      ref: \"user\"\r\n    }\r\n  });\r\n\r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        owner: {\r\n          type: \"ONE_ONE\",\r\n          model: \"user\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return Schema;\r\n};\r\n```\r\n\r\n### ONE_MANY/MANY_ONE\r\n\r\nBelow is an example of a one-many/many-one relationship between the ``user``\r\nand ``role`` models.  Notice the ``title`` field in the schema.  A schema\r\nfield is required for associations of type ``ONE_ONE`` or ``MANY_ONE``.  This\r\nfield must match the association name, include a type of ``ObjectId``, and\r\ninclude a ``ref`` property with the associated model name.\r\n\r\n``/api/models/user.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    },\r\n    title: {\r\n      type: Types.ObjectId,\r\n      ref: \"role\"\r\n    }\r\n\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        title: {\r\n          type: \"MANY_ONE\",\r\n          model: \"role\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\n``/api/models/role.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"role\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    name: {\r\n      type: Types.String,\r\n      required: true,\r\n      enum: [\"Account\", \"Admin\", \"SuperAdmin\"]\r\n    },\r\n    description: {\r\n      type: Types.String\r\n    }\r\n  });\r\n\r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        users: {\r\n          type: \"ONE_MANY\",\r\n          foreignField: \"title\",\r\n          model: \"user\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return Schema;\r\n};\r\n```\r\n\r\nIn this example, a user can belong to one role and a role can be \r\nassigned to many users.  The ``type`` and ``model`` fields are\r\nrequired for all associations, and the ``foreignField`` field is \r\nrequired for ``ONE_MANY`` type associations.  \r\n\r\nAlong with the normal CRUD endpoints, the following association \r\nendpoints will be generated for the ``role`` model:\r\n\r\n```\r\nGET /role/{ownerId}/user                Gets all of the users for a role\r\nPOST /role/{ownerId}/user               Sets multiple users for a role\r\nPUT /role/{ownerId}/user/{childId}      Add a single user object to a role's list of users\r\nDELETE /role/{ownerId}/user/{childId}   Remove a single user object from a role's list of users\r\n```\r\n\r\n### MANY_MANY\r\n\r\nBelow is an example of a many-many relationship between the ``user`` and\r\n``group`` models. In this relationship a single ``user`` instance can belong\r\nto multiple ``group`` instances and vice versa.\r\n\r\n``/api/models/user.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        groups: {\r\n          type: \"MANY_MANY\",\r\n          model: \"group\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\n\r\n``/api/models/group.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"group\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    name: {\r\n      type: Types.String,\r\n      required: true,\r\n    },\r\n    description: {\r\n      type: Types.String\r\n    }\r\n  });\r\n\r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        users: {\r\n          type: \"MANY_MANY\",\r\n          model: \"user\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return Schema;\r\n};\r\n```\r\n\r\n\r\nAlong with the normal CRUD endpoints, the following association \r\nendpoints will be generated for the ``user`` model:\r\n\r\n```\r\nGET /user/{ownerId}/group               Gets all of the groups for a user\r\nPOST /user/{ownerId}/group              Sets multiple groups for a user\r\nPUT /user/{ownerId}/group/{childId}     Add a single group object to a user's list of groups\r\nDELETE /user/{ownerId}/group/{childId}  Remove a single group object from a user's list of groups\r\n```\r\n\r\nand for the ``group`` model:\r\n\r\n```\r\nGET /group/{ownerId}/user               Gets all of the users for a group\r\nPOST /group/{ownerId}/user              Sets multiple users for a group\r\nPUT /group/{ownerId}/user/{childId}     Add a single user object to a group's list of users\r\nDELETE /group/{ownerId}/user/{childId}  Remove a single user object from a group's list of users\r\n```\r\n\r\n#### MANY_MANY linking models\r\n\r\nMany-many relationships can include extra fields that contain data specific\r\nto each association instance.  This is accomplished through linking models which\r\nbehave similar to pivot tables in a relational database.  Linking model files are\r\nstored in the ``/api/models/linking-models`` directory and follow the same \r\n``{name}.model.js`` format as normal models.  Below is an example of a many-many\r\nrelationship between the ``user`` model and itself through the ``friends`` association.\r\nThe extra field ``friendsSince`` could contain a date representing how long the two\r\nassociated users have known each other.  This example also displays how models can contain a \r\nreference to themselves.  \r\n\r\n\r\n``/api/models/user.model.js``:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      associations: {\r\n        friends: {\r\n          type: \"MANY_MANY\",\r\n          model: \"user\",\r\n          alias: \"friend\",\r\n          linkingModel: \"user_user\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\n\r\n``/api/models/linking-models/user_user.model.js``:\r\n\r\n```javascript\r\nvar mongoose = require(\"mongoose\");\r\n\r\nmodule.exports = function () {\r\n\r\n  var Types = mongoose.Schema.Types;\r\n\r\n  var Model = {\r\n    Schema: {\r\n      friendsSince: {\r\n        type: Types.Date\r\n      }\r\n    },\r\n    modelName: \"user_user\"\r\n  };\r\n\r\n  return Model;\r\n};\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Route customization\r\nBy default route paths are constructed using model names, however aliases can be provided to customize the route paths.\r\n``routeOptions.alias`` can be set to alter the base path name, and an ``alias`` property for an association can be set \r\nto alter the association path name.  For example:\r\n\r\n```javascript\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName: modelName\r\n    routeOptions: {\r\n      alias: \"person\"\r\n      associations: {\r\n        groups: {\r\n          type: \"MANY_MANY\",\r\n          model: \"group\",\r\n          alias: \"team\"\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\nwill result in the following endpoints:\r\n\r\n```\r\nGET /person \r\nPOST /person\r\nDELETE /person/{_id} \r\nPUT /person/{_id} \r\nGET /person/{_id} \r\nPOST /person/{ownerId}/team \r\nGET /person/{ownerId}/team \r\nPUT /person/{ownerId}/team/{childId} \r\nDELETE /person/{ownerId}/team/{childId}\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Querying\r\n\r\nQuery parameters can be added to GET requests to filter responses.  These parameters\r\nare structured and function similar to mongoose queries.  Below is a list of currently \r\nsupported parameters:\r\n\r\n* $skip\r\n    - The number of records to skip in the database. This is typically used in pagination.\r\n\r\n* $limit\r\n    - The maximum number of records to return. This is typically used in pagination.\r\n    \r\n* $select\r\n    - A list of basic fields to be included in each resource.\r\n\r\n* $sort\r\n    - A set of fields to sort by. Including field name indicates it should be sorted ascending, \r\n    while prepending '-' indicates descending. The default sort direction is 'ascending' \r\n    (lowest value to highest value). Listing multiple fields prioritizes the sort starting with the first field listed. \r\n\r\n* $embed\r\n    - A set of associations to populate. \r\n\r\n* $where\r\n    - An optional field for raw mongoose queries.\r\n\r\n* (field \"where\" queries)\r\n    - Ex: ``/user?email=test@user.com``\r\n    \r\nQuery parameters can either be passed in as a single string, or an array of strings.\r\n\r\n### Populate nested associations\r\nAssociations can be populated through the ``$embed`` parameter.  To populate nested associations,\r\nsimply chain a parameter with ``.``.  For example, consider the MANY_MANY group-user association\r\nfrom the example above.  If we populate the users of a group with ``/group?$embed=users`` we might get a \r\nresponse like so:\r\n\r\n```json\r\n{\r\n    \"_id\": \"58155f1a071468d3bda0fc6e\",\r\n    \"name\": \"A-team\",\r\n    \"users\": [\r\n      {\r\n        \"user\": {\r\n          \"_id\": \"580fc1a0e2d3308609470bc6\",\r\n          \"email\": \"test@user.com\",\r\n          \"title\": \"580fc1e2e2d3308609470bc8\"\r\n        },\r\n        \"_id\": \"58155f6a071468d3bda0fc6f\"\r\n      },\r\n      {\r\n        \"user\": {\r\n          \"_id\": \"5813ad3d0d4e5c822d2f05bd\",\r\n          \"email\": \"test2@user.com\",\r\n          \"title\": \"580fc1eee2d3308609470bc9\"\r\n        },\r\n        \"_id\": \"58155f6a071468d3bda0fc71\"\r\n      }\r\n    ]\r\n}\r\n```\r\n\r\nHowever we can further populate each user's ``title`` field with a nested ``$embed``\r\nparameter: ``/group?$embed=users.title`` which could result in the following response:\r\n\r\n```json\r\n{\r\n    \"_id\": \"58155f1a071468d3bda0fc6e\",\r\n    \"name\": \"A-team\",\r\n    \"users\": [\r\n      {\r\n        \"user\": {\r\n          \"_id\": \"580fc1a0e2d3308609470bc6\",\r\n          \"email\": \"test@user.com\",\r\n          \"title\": {\r\n            \"_id\": \"580fc1e2e2d3308609470bc8\",\r\n            \"name\": \"Admin\"\r\n          }\r\n        },\r\n        \"_id\": \"58155f6a071468d3bda0fc6f\"\r\n      },\r\n      {\r\n        \"user\": {\r\n          \"_id\": \"5813ad3d0d4e5c822d2f05bd\",\r\n          \"email\": \"test2@user.com\",\r\n          \"title\": {\r\n            \"_id\": \"580fc1eee2d3308609470bc9\",\r\n            \"name\": \"SuperAdmin\"\r\n          }\r\n        },\r\n        \"_id\": \"58155f6a071468d3bda0fc71\"\r\n      }\r\n    ]\r\n}\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Validation\r\nValidation in the rest-hapi framework is implemented with [joi](https://github.com/hapijs/joi).  \r\nThis includes validation of headers, query parameters, payloads, and responses.  joi validation models\r\nare based primarily off of each model's field properties.  Below is a list of mongoose schema types \r\nand their joi equivalent within rest-hapi:\r\n\r\nSchema Type | joi Validation\r\n--- | --- \r\nObjectId    |      Joi.objectId() (via [joi-objectid](https://www.npmjs.com/package/joi-objectid))\r\nBoolean     |      Joi.bool()\r\nNumber      |      Joi.number()\r\nDate        |      Joi.date()\r\nString      |      Joi.string()\r\ntypes       |      Joi.any()\r\n\r\nFields of type ``String`` that include an ``enum`` property result in the following joi validation:\r\n\r\nField Property | joi Validation\r\n--- | ---\r\nenum: [items] | Joi.any().only([items])\r\n\r\n\r\nrest-hapi generates joi validation models for create, read, and update events as well as association events with linking models.  By default these validation models include all the fields of the mongoose models and list them as optional.  However additional field properties can be included to customize the validation models.  Below is a list of currently supported field properties and their effect on the validation models.\r\n\r\nField Property | Validation Model\r\n--- | ---\r\nrequired: true | field required on create\r\nrequireOnRead: true | field required on read/response\r\nrequireOnUpdate: true | field required on update\r\nallowOnRead: false | field excluded from read model\r\nallowOnUpdate: false | field excluded from update model\r\nallowOnUpdate: false | field excluded from create model\r\nqueryable: false | field cannot be included as a query parameter\r\nexclude: true | field cannot be included in a response or as part of a query\r\nallowNull: true | field accepts ``null`` as a valid value\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Middleware\r\nModels can support middleware functions for CRUD operations. These\r\nexist under the ``routeOptions`` object. Middleware functions must return\r\n a promise.  The following middleware functions\r\nare available:\r\n\r\n* list: \r\n    - post(request, result, Log)\r\n* find: \r\n    - post(request, result, Log)\r\n* create:\r\n    - pre(request, Log)\r\n    - post(request, result, Log)\r\n* update: \r\n    - pre(request, Log)\r\n    - post(request, result, Log)\r\n* delete: \r\n    - pre(request, Log)\r\n    - post(request, result, Log)\r\n\r\n\r\nFor example, a ``create: pre`` function can be defined to encrypt a users password\r\nusing the built-in ``password-helper`` utility.  Notice the use of the ``Q`` library\r\nto return a promise.\r\n \r\n```javascript\r\nvar Q = require('q');\r\n\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics= {\r\n    collectionName: modelName\r\n    routeOptions: {\r\n      create: {\r\n        pre: function (request, Log) {\r\n          var deferred = Q.defer();\r\n          var passwordUtility = require('../../api/utilities/password-helper');\r\n          var hashedPassword = passwordUtility.hash_password(request.payload.password);\r\n\r\n          request.payload.password = hashedPassword;\r\n          deferred.resolve(request);\r\n          return deferred.promise;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Additional endpoints\r\nIf endpoints beyond the generated CRUD endpoints are needed, they can easily be added \r\nto a model as an item in the ``routeOptions.extraEndpoints`` array.  The endpoint\r\nlogic should be contained within a function using the footprint: ``function (server, model, options, Log)``\r\n. For example, if we wanted to add a ``Password Update`` endpoint to the ``user`` model, it could\r\nlook like this:\r\n\r\n```javascript\r\nvar Joi = require('joi');\r\nJoi.objectId = require('joi-objectid')(Joi);\r\nvar Boom = require('boom');\r\n\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      extraEndpoints: [\r\n        //Password Update Endpoint\r\n        function (server, model, options, Log) {\r\n          Log = Log.bind(\"Password Update\");\r\n\r\n          var collectionName = model.collectionDisplayName || model.modelName;\r\n\r\n          Log.note(\"Generating Password Update endpoint for \" + collectionName);\r\n\r\n          var handler = function (request, reply) {\r\n            var passwordUtility = require('../../api/utilities/password-helper');\r\n            var hashedPassword = passwordUtility.hash_password(request.payload.password);\r\n            return model.findByIdAndUpdate(request.params._id, {password: hashedPassword}).then(function (result) {\r\n              if (result) {\r\n                return reply(\"Password updated.\").code(200);\r\n              }\r\n              else {\r\n                return reply(Boom.notFound(\"No resource was found with that id.\"));\r\n              }\r\n            })\r\n            .catch(function (error) {\r\n              Log.error(\"error: \", error);\r\n              return reply(Boom.badImplementation(\"An error occurred updating the resource.\", error));\r\n            });\r\n          }\r\n\r\n          server.route({\r\n            method: 'PUT',\r\n            path: '/user/{_id}/password',\r\n            config: {\r\n              handler: handler,\r\n              auth: null,\r\n              description: 'Update a user\\'s password.',\r\n              tags: ['api', 'User', 'Password'],\r\n              validate: {\r\n                params: {\r\n                  _id: Joi.objectId().required()\r\n                },\r\n                payload: {\r\n                  password: Joi.string().required()\r\n                  .description('The user\\'s new password')\r\n                }\r\n              },\r\n              plugins: {\r\n                'hapi-swagger': {\r\n                  responseMessages: [\r\n                    {code: 200, message: 'Success'},\r\n                    {code: 400, message: 'Bad Request'},\r\n                    {code: 404, message: 'Not Found'},\r\n                    {code: 500, message: 'Internal Server Error'}\r\n                  ]\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n      ]\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Token authentication\r\nThe rest-hapi framework supports built in token authentication for all generated endpoints given the following requirements are fulfilled:\r\n\r\n- A ``user`` model exists with at least the following properties:\r\n\r\n```javascript\r\nvar Q = require('q');\r\n\r\nmodule.exports = function (mongoose) {\r\n  var modelName = \"user\";\r\n  var Types = mongoose.Schema.Types;\r\n  var Schema = new mongoose.Schema({\r\n    email: {\r\n      type: Types.String,\r\n      required: true,\r\n      unique: true\r\n    },\r\n    password: {\r\n      type: Types.String,\r\n      required: true,\r\n      exclude: true,\r\n      allowOnUpdate: false\r\n    },\r\n    token: {\r\n      type: Types.String,\r\n      allowNull: true,\r\n      exclude: true,\r\n      allowOnUpdate: false,\r\n      allowOnCreate: false\r\n    },\r\n    tokenCreatedAt: {\r\n      type: Types.String,\r\n      allowNull: true,\r\n      exclude: true,\r\n      allowOnUpdate: false,\r\n      allowOnCreate: false\r\n    }\r\n  });\r\n  \r\n  Schema.statics = {\r\n    collectionName:modelName,\r\n    routeOptions: {\r\n      create: {\r\n        pre: function (request, Log) {\r\n          var deferred = Q.defer();\r\n          var passwordUtility = require('../../api/utilities/password-helper');\r\n          var hashedPassword = passwordUtility.hash_password(request.payload.password);\r\n\r\n          request.payload.password = hashedPassword;\r\n          deferred.resolve(request);\r\n          return deferred.promise;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return Schema;\r\n};\r\n```\r\n**NOTE:** Token authentication requires that passwords are encrypted using the password helper as above.\r\n\r\n- The ``auth`` property in the config file is set to ``\"token\"``.\r\n\r\nGiven these conditions, a new endpoint will be generated:\r\n\r\n```\r\nPOST /token     Create a token for a user.\r\n```\r\n\r\nThis endpoint takes a user email and password as a payload and returns an authentication token.  When token authentication is enabled, all generated enpoints require an Authentication header:\r\n\r\n```\r\nAuthorization: Bearer USER_TOKEN\r\n```\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## License\r\nMIT\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Questions?\r\nIf you have any questions/issues/feature requests, please feel free to open an issue.\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Future work\r\nThis project is still in its infancy, and there are many features I would still like to add.  Below is a list of some possible future updates:\r\n\r\n- support mongoose ``$text`` search query parameter\r\n- sorting through populate fields (Ex: sort users through role.name)\r\n- have built in ``created_at`` and ``updated_at`` fields for each model\r\n- support marking fields as ``duplicate`` i.e. any associated models referencing that model will duplicate those fields along with the reference Id. This could allow for a shallow embed that will return a list of reference ids with their \"duplicate\" values, and a full embed that will return the fully embedded references\r\n- support automatic logging of all operations via a ``eventLogs`` collection\r\n- support \"soft\" delete of mongo documents, i.e. documents are marked as \"deleted\" but remain in the db.\r\n- (LONG TERM) support mysql as well as mongodb\r\n\r\n[Back to top](#readme-contents)\r\n\r\n## Contributing\r\nPlease reference the contributing doc: https://github.com/JKHeadley/rest-hapi/blob/master/CONTRIBUTING.md\r\n\r\n[Back to top](#readme-contents)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}